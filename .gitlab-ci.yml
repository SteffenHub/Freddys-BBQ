#
# Make sure you have set the environment variables for the deployment
# - SSH_USER: The ssh user for your server
# - SSH_KEY: The private ssh key to connect to your server
# - SERVER_IP: The server ip to connect to your server
#
# You also have to copy the 'docker-compose-server-file.yml' in to the $SSH_USER /app folder and rename it to 'docker-compose.yml'
# Set the correct docker registry paths in this file.
# Provide and export environment variables containing MAIL_USERNAME und MAIL_PASSWORD you can use the 'deploy-app.sh' script for help
#
variables:
  DOCKER_PROJECT_NAME: "freddys-bbq"
  DOCKER_HOST: tcp://docker:2375
  # Disables TLS, which is required for dind in GitLab CI
  DOCKER_TLS_CERTDIR: ""
  # Improves the performance of the dind driver
  DOCKER_DRIVER: overlay2

stages:
  - test
  - build
  - deploy

# Job to run the backend and frontend tests
run-tests:
  stage: test
  image: docker:26-cli # Newer docker image required to install dependencies like openjdk21

  #Start the Docker daemon (Docker-in-Docker) as a service
  services:
    - name: docker:dind
      alias: docker

# Install Java and Gradle, as they are not included in the docker:26-cli image
  before_script:
    - apk add --no-cache openjdk21 gradle

  # Cache Gradle dependencies to speed up future pipeline runs
  cache:
    key: "$CI_COMMIT_REF_SLUG-gradle"
    paths:
      - .gradle/
      - ~/.gradle/caches/

  parallel:
    matrix:
      - MODULE:
          - Backend/delivery
          - Backend/order
          - Frontend/customer
          - Frontend/Intern
  script:
    - echo "--- Running tests for $MODULE ---"
    - cd $MODULE && ./gradlew test



# Builds all services from the docker compose yml and pushes it to the gitlab registry
build-images:
  stage: build
  image: docker/compose:latest
  services:
    - name: docker:dind
      alias: docker
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_JOB_TOKEN" "$CI_REGISTRY"
  script:
    - echo "--- Building all services from docker-compose.yml ---"
    - docker-compose build

    - echo "--- Tagging and pushing images to GitLab Registry ---"
    - |
      PROJECT_NAME=$(basename "$CI_PROJECT_DIR" | tr '[:upper:]' '[:lower:]')
      echo "Project name detected as: $PROJECT_NAME"
      
      SERVICES="frontend-customer frontend-intern backend-order backend-delivery backend-mail backend-rabbitmq"
      for SERVICE in $SERVICES; do
        SOURCE_IMAGE="${PROJECT_NAME}_${SERVICE}"
        TARGET_IMAGE="$CI_REGISTRY_IMAGE/$SERVICE"
      
        echo "Tagging $SOURCE_IMAGE as $TARGET_IMAGE:$CI_COMMIT_SHA"
        docker tag "$SOURCE_IMAGE" "$TARGET_IMAGE:$CI_COMMIT_SHA"
        docker push "$TARGET_IMAGE:$CI_COMMIT_SHA"
      
        if [[ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]]; then
          echo "Tagging as latest..."
          docker tag "$SOURCE_IMAGE" "$TARGET_IMAGE:latest"
          docker push "$TARGET_IMAGE:latest"
        fi
      done
  rules:
    - if: $CI_COMMIT_BRANCH
      exists:
        - docker-compose.yml


.setup_ssh: &setup_ssh
  # Create the .ssh folder
  - mkdir -p ~/.ssh
  # paste the ssh key into the .ssh folder
  - echo "$SSH_KEY" | base64 -d > ~/.ssh/id_rsa
  # Make the shh accessible
  - chmod 600 ~/.ssh/id_rsa
  # Add the server ip as a known host
  - ssh-keyscan -H $SERVER_IP >> ~/.ssh/known_hosts

.deploy_app: &deploy_app
  - |
    ssh "$SSH_USER@$SERVER_IP" "
        echo '--- Logging into GitLab Registry on server ---'
        docker login -u '$CI_REGISTRY_USER' -p '$CI_JOB_TOKEN' '$CI_REGISTRY'
    
        echo '--- Pulling latest images ---'
        cd /$SSH_USER/app && docker-compose pull
    
        echo '--- Starting application with Docker Compose ---'
        cd /$SSH_USER/app && docker-compose up -d --remove-orphans
      "

deploy_main:
  stage: deploy
  image: alpine:latest

  needs:
    - build-images
  before_script:
    - apk add --no-cache openssh-client
  script:
    - *setup_ssh
    - *deploy_app
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual